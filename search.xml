<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LLDB</title>
      <link href="/2022/05/24/284708204981.html"/>
      <url>/2022/05/24/284708204981.html</url>
      
        <content type="html"><![CDATA[<h1 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h1><ul><li><code>po</code>: 为 print object 的缩写，显示对象的文本描述, <code>expression -O</code>的别称</li><li><code>bt</code>: 打印当前堆栈信息</li><li><code>register read xx</code>: 读取寄存器</li><li><code>memory read/个数+格式+每个地址单元的长度 内存地址</code> 查看内存数据<ul><li>默认为：memory read&#x2F;16xb</li><li><code>格式</code>: x-16进制、f-浮点数，d-10进制，u-10进制无符号，o-8进制，t-2进制<br>  a-16进制格式+实际地址类型，i-指令地址格式，c-按字符格式</li><li><code>字节数</code>: b-1个字节，h-2个字节，w-4个字节，g-8个字节。</li><li><code>x = memory read</code> x&#x2F;16xb</li></ul></li><li><code>memory write 地址 数据</code> 向指定内存写入数据<span id="more"></span>命令格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 命令 + 子命令 + 命令选项 + 命令参数</span><br><span class="line">&lt;command&gt; [&lt;subcom&gt; [&lt;subcom&gt;...]] &lt;action&gt; [-options [optionvalue]] [arg [arg...]]</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2></li></ul><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p>执行表达式并将表达式的执行结果输出打印。开发中常用po来打印对象，po实际上就是expression -O的别名。</p><h3 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint"></a>breakpoint</h3><p>代码调试断点</p><h5 id="指定文件和行号设置断点："><a href="#指定文件和行号设置断点：" class="headerlink" title="指定文件和行号设置断点："></a>指定文件和行号设置断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set --file easeapi.c --line 12</span><br><span class="line">breakpoint set -f ViewController.m -l 12</span><br></pre></td></tr></table></figure><h5 id="指定函数名称设置断点："><a href="#指定函数名称设置断点：" class="headerlink" title="指定函数名称设置断点："></a>指定函数名称设置断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//对于C函数，填写完整的函数名称。</span><br><span class="line">breakpoint set --name easeapi_func</span><br><span class="line">breakpoint set -n easeapi_func</span><br><span class="line"></span><br><span class="line">//对于Objective-C函数，填写完整的方法签名Selector字符串。</span><br><span class="line">breakpoint set -n viewDidAppear:</span><br><span class="line">breakpoint set -n tableView:cellForRowAtIndexPath:</span><br><span class="line"></span><br><span class="line">//对于Swift方法，填写函数名称，参数省略。</span><br><span class="line">breakpoint set -n easeapi_func</span><br></pre></td></tr></table></figure><h5 id="指定对象方法设置断点："><a href="#指定对象方法设置断点：" class="headerlink" title="指定对象方法设置断点："></a>指定对象方法设置断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -n &quot;-[ViewController viewDidAppear:]&quot;</span><br><span class="line">breakpoint set -n &quot;+[ViewController classFunc]&quot;</span><br><span class="line">//Swift函数</span><br><span class="line">breakpoint set -n &quot;ViewController.easeapi_func&quot;</span><br></pre></td></tr></table></figure><h5 id="指定代码地址设置断点："><a href="#指定代码地址设置断点：" class="headerlink" title="指定代码地址设置断点："></a>指定代码地址设置断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set --address 0x1021744bb</span><br><span class="line">breakpoint set -a 0x1021744bb</span><br></pre></td></tr></table></figure><h5 id="查看已设置的断点"><a href="#查看已设置的断点" class="headerlink" title="查看已设置的断点"></a>查看已设置的断点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint list</span><br></pre></td></tr></table></figure><p>每一次设置的断点都是逻辑断点（对应编号1、2、3等），一个逻辑断点可以解析为多个断点位置（对应编号1.1等）</p><h5 id="取消断点"><a href="#取消断点" class="headerlink" title="取消断点"></a>取消断点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">breakpoint delete 断点编号</span><br></pre></td></tr></table></figure><p>若不加编号则为所有断点</p><h4 id="watchpoint"><a href="#watchpoint" class="headerlink" title="watchpoint"></a>watchpoint</h4><p>内存调试断点</p><h5 id="设置观察变量："><a href="#设置观察变量：" class="headerlink" title="设置观察变量："></a>设置观察变量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchpoint set variable value</span><br><span class="line">watchpoint set variable self-&gt;_dataArray //不能使用点语法</span><br></pre></td></tr></table></figure><h5 id="设置观察内存地址："><a href="#设置观察内存地址：" class="headerlink" title="设置观察内存地址："></a>设置观察内存地址：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint set expression 0x000000016f47fc70</span><br></pre></td></tr></table></figure><h5 id="查看所有内存断点："><a href="#查看所有内存断点：" class="headerlink" title="查看所有内存断点："></a>查看所有内存断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint list</span><br></pre></td></tr></table></figure><h5 id="删除内存断点："><a href="#删除内存断点：" class="headerlink" title="删除内存断点："></a>删除内存断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchpoint delete index</span><br><span class="line">watchpoint delete</span><br></pre></td></tr></table></figure><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>寄存器操作</p><p><code>register read</code> 读取所有寄存器<br>ARM64架构中共有34个寄存器，包括31个通用寄存器、SP、PC、CPSR。</p><ul><li>通用寄存器<ul><li>r0 - r30是31个通用寄存器，每个寄存器可以存取一个64位大小的数。 </li><li>当使用x0 - x30访问时，它就是一个64位的数。</li><li>当使用w0 - w30访问时，是这些寄存器的低32位。  </li><li>r29又称FP寄存器(frame point)，主要用来保存栈帧（栈底）指针。 </li><li>r30又称LR寄存器(link register)，主要用来保存函数返回地址。</li></ul></li><li>SP：stack pointer，栈顶指针；</li><li>PC：用来记录当前执行的指令地址；</li><li>CPSR：状态寄存器。</li></ul><p>读取指定寄存器的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register read x1</span><br></pre></td></tr></table></figure><p>写入寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register write x0 1</span><br></pre></td></tr></table></figure><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>内存操作</p><h4 id="从内存读取数据"><a href="#从内存读取数据" class="headerlink" title="从内存读取数据"></a>从内存读取数据</h4><p><code>memory read/个数+格式+每个地址单元的长度 内存地址</code></p><ul><li>默认为：memory read&#x2F;16xb</li><li><code>格式</code>: x-16进制、f-浮点数，d-10进制，u-10进制无符号，o-8进制，t-2进制；<br> a-16进制格式+实际地址类型，i-指令地址格式，c-按字符格式</li><li><code>字节数</code>: b-1个字节，h-2个字节，w-4个字节，g-8个字节。</li></ul><p>等价于 <code>x/16xb = memory read/16xb</code></p><h4 id="往内存写入数据"><a href="#往内存写入数据" class="headerlink" title="往内存写入数据"></a>往内存写入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory write 地址 数据</span><br><span class="line">//以8字节对齐，写入两个数据</span><br><span class="line">memory write 0x000000016f08fc70 -s 8 0x01 0x02</span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image镜像文件操作</p><p>查看已经加载的Image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list</span><br></pre></td></tr></table></figure><p>查看信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查找类信息</span><br><span class="line">image lookup --type UIViewController</span><br><span class="line">image lookup -t UIViewController</span><br><span class="line">//查找符号</span><br><span class="line">image lookup --name viewDidLoad</span><br><span class="line">image lookup -n viewDidLoad</span><br><span class="line">//查找地址</span><br><span class="line">image lookup --address 0x000000018ff60490</span><br><span class="line">image lookup -a 0x000000018ff60490</span><br></pre></td></tr></table></figure><p>导出image信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//导出所有sections信息</span><br><span class="line">image dump sections</span><br><span class="line">//导出所有符号信息</span><br><span class="line">image dump symtab</span><br></pre></td></tr></table></figure><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>线程操作</p><p>查看线程列表<br><code>thread list</code><br>其中，使用*标记当前线程；使用#标记线程编号。</p><p>获取线程调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取当前线程调用栈</span><br><span class="line">thread backtrace</span><br><span class="line">//函数的堆栈</span><br><span class="line">bt</span><br><span class="line">//获取所有线程调用栈</span><br><span class="line">thread backtrace all</span><br></pre></td></tr></table></figure><p>在Xcode中，有四个控制Debug的按钮：</p><ul><li>Continue：程序继续运行<br>  <code>thread continue/continue/c</code></li><li>Step over：单步指定，遇到子函数时断点不会进入子函数。<br>  <code>thread step-over/next/n</code></li><li>Step into：单步运行，遇到子函数时断点会进入子函数。<br>  <code>thread step-into/step/s</code></li><li>Step out：执行完当前函数剩余的代码，返回上一层函数。<br>  <code>thread step-out/finish</code></li></ul><p>修改函数返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread return 10</span><br></pre></td></tr></table></figure><h3 id="frame"><a href="#frame" class="headerlink" title="frame"></a>frame</h3><p>栈帧信息<br>查看当前栈帧变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame variable</span><br></pre></td></tr></table></figure><h3 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h3><p>显示汇编代码<br>使用d&#x2F;di&#x2F;dis同等效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">disassemble -b</span><br><span class="line">disassemble --frame</span><br><span class="line">disassemble --name func_name</span><br><span class="line">disassemble -a address</span><br><span class="line">disassemble -s address</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xcode </tag>
            
            <tag> iOS </tag>
            
            <tag> LLDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter布局约束</title>
      <link href="/2022/05/24/75dbaf21f054.html"/>
      <url>/2022/05/24/75dbaf21f054.html</url>
      
        <content type="html"><![CDATA[<h1 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h1><p>Flutter 中有两种布局模型：</p><ul><li>基于 RenderBox 的盒模型布局。</li><li>基于 Sliver ( RenderSliver ) 按需加载列表布局。</li></ul><p>大致布局流程如下：</p><ol><li>上层组件向下层组件传递约束（constraints）条件。</li><li>下层组件确定自己的大小，然后告诉上层组件。注意下层组件的大小必须符合父组件的约束。</li><li>上层组件确定下层组件相对于自身的偏移和确定自身的大小（大多数情况下会根据子组件的大小来确定自身的大小）。</li></ol><p><code>因为任何时候子组件都必须先遵守父组件的约束</code></p><span id="more"></span><p>盒模型布局组件有两个特点：</p><ol><li>组件对应的渲染对象都继承自 RenderBox 类。在本书后面文章中如果提到某个组件是 RenderBox，则指它是基于盒模型布局的，而不是说组件是 RenderBox 类的实例。</li><li>在布局过程中父级传递给子级的约束信息由 BoxConstraints 描述。</li></ol><h3 id="BoxConstraints-父-gt-子-的约束信息"><a href="#BoxConstraints-父-gt-子-的约束信息" class="headerlink" title="BoxConstraints (父-&gt;子)的约束信息"></a>BoxConstraints (父-&gt;子)的约束信息</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints(&#123;</span><br><span class="line">  <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>, <span class="comment">//最小宽度</span></span><br><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity, <span class="comment">//最大宽度</span></span><br><span class="line">  <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>, <span class="comment">//最小高度</span></span><br><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity <span class="comment">//最大高度</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>BoxConstraints.tight(Size size)，它可以生成固定宽高的限制；<br>BoxConstraints.expand()可以生成一个尽可能大的用以填充另一个容器的BoxConstraints;</p><h3 id="ConstrainedBox"><a href="#ConstrainedBox" class="headerlink" title="ConstrainedBox"></a>ConstrainedBox</h3><p>通过约束限制子组件大小的组件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临时定义一个</span></span><br><span class="line">Widget yellowBox = <span class="keyword">const</span> DecoratedBox(</span><br><span class="line">  decoration: BoxDecoration(color: Colors.yellow),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget testConstrainedBox() &#123;</span><br><span class="line">  <span class="keyword">return</span> ConstrainedBox( <span class="comment">// 父组件</span></span><br><span class="line">    constraints: <span class="keyword">const</span> BoxConstraints( <span class="comment">// 父组件对子组件的 约束信息</span></span><br><span class="line">        minWidth: <span class="built_in">double</span>.infinity, <span class="comment">// 宽度尽可能大</span></span><br><span class="line">        minHeight: <span class="number">80.0</span> <span class="comment">// 最小高度为80像素</span></span><br><span class="line">        ),</span><br><span class="line">    child: SizedBox( <span class="comment">// 子组件</span></span><br><span class="line">      height: <span class="number">20.0</span>, <span class="comment">// 虽然20小于80， 但是父组件约束了最小为80</span></span><br><span class="line">      child: yellowBox,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><img src="/2022/05/24/75dbaf21f054/16533793465334.jpg" class=""> <p>虽然自组件设置的高是20, 但是父组件约束了最小为80, 所以高度是80</p><h4 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h4><p>SizedBox只是ConstrainedBox的一个定制,</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SizedBox(width: <span class="number">80.0</span>, height: <span class="number">80.0</span>, child: yellowBox)</span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints.tightFor(width: <span class="number">80.0</span>, height: <span class="number">80.0</span>),</span><br><span class="line">  child: yellowBox, </span><br><span class="line">)</span><br><span class="line"><span class="comment">// 又等价于</span></span><br><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints(minHeight: <span class="number">80.0</span>, maxHeight: <span class="number">80.0</span>, minWidth: <span class="number">80.0</span>, maxWidth: <span class="number">80.0</span>),</span><br><span class="line">  child: yellowBox, </span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="/2022/05/24/75dbaf21f054/16533795446838.jpg" class=""><p>其实<code>ConstrainedBox</code>和<code>SizedBox</code>都是通过<code>RenderConstrainedBox</code>来渲染的;</p><h4 id="多层约束"><a href="#多层约束" class="headerlink" title="多层约束"></a>多层约束</h4><p>如果使用多层ConstrainedBox父组件 会是什么情况呢?</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外小 内大</span></span><br><span class="line">ConstrainedBox( <span class="comment">// 祖父组件</span></span><br><span class="line">  constraints: BoxConstraints(minWidth: <span class="number">140.0</span>, minHeight: <span class="number">40.0</span>),</span><br><span class="line">  child: ConstrainedBox( <span class="comment">// 父组件</span></span><br><span class="line">    constraints: BoxConstraints(minWidth: <span class="number">180.0</span>, minHeight: <span class="number">80.0</span>),</span><br><span class="line">    child: yellowBox, <span class="comment">// 子组件</span></span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 外大 内小</span></span><br><span class="line">ConstrainedBox( <span class="comment">// 祖父组件</span></span><br><span class="line">  constraints: BoxConstraints(minWidth: <span class="number">180.0</span>, minHeight: <span class="number">80.0</span>),</span><br><span class="line">  child: ConstrainedBox( <span class="comment">// 父组件</span></span><br><span class="line">    constraints: BoxConstraints(minWidth: <span class="number">140.0</span>, minHeight: <span class="number">40.0</span>),</span><br><span class="line">    child: yellowBox, <span class="comment">// 子组件</span></span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="/2022/05/24/75dbaf21f054/16533807548379.jpg" class=""><p>因为约束条件是用来约束子组件的</p><ul><li>一层约束时很好理解, 即: <code>maxSize &gt;= 最终大小 &amp;&amp; 最终大小 &gt;= minSize</code></li><li>那两层也不难理解, 只要两层约束条件都满足即可:  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxSize1 &gt;= 最终大小 &amp;&amp; 最终大小 &gt;= minSize1</span></span><br><span class="line"><span class="comment">// &amp;&amp;</span></span><br><span class="line"><span class="comment">// maxSize2 &gt;= 最终大小 &amp;&amp; 最终大小 &gt;= minSize2</span></span><br><span class="line"><span class="comment">// 整理即可得出 </span></span><br><span class="line"><span class="comment">// min(maxSize1, maxSize2) &gt;= 最终大小 &gt;= max(minSize1, minSize2)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="UnconstrainedBox"><a href="#UnconstrainedBox" class="headerlink" title="UnconstrainedBox"></a>UnconstrainedBox</h3><p>虽然任何时候子组件都必须遵守其父组件的约束，但前提条件是它们必须是父子关系，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConstrainedBox( <span class="comment">// 曾祖父组件</span></span><br><span class="line">  constraints: BoxConstraints(minWidth: <span class="number">180.0</span>, minHeight: <span class="number">80.0</span>), <span class="comment">// 曾祖父组件约束</span></span><br><span class="line">  child: UnconstrainedBox( <span class="comment">// 祖父组件, “去除”曾祖父组件的约束</span></span><br><span class="line">    child: ConstrainedBox( <span class="comment">// 父组件</span></span><br><span class="line">      constraints: BoxConstraints(minWidth: <span class="number">80.0</span>, minHeight: <span class="number">30.0</span>), <span class="comment">// 父组件约束</span></span><br><span class="line">      child: yellowBox, <span class="comment">// 子组件</span></span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="/2022/05/24/75dbaf21f054/16533826173981.jpg" class=""><p><strong>任何时候子组件都必须遵守其父组件的约束</strong></p><p>需要注意，UnconstrainedBox 虽然在其子组件布局时可以取消约束（子组件可以为无限大），但是 UnconstrainedBox 自身是受其父组件约束的，所以当 UnconstrainedBox 随着其子组件变大后，如果UnconstrainedBox 的大小超过它父组件约束时，也会导致溢出报错!</p><h3 id="其他约束类"><a href="#其他约束类" class="headerlink" title="其他约束类"></a>其他约束类</h3><p>还有一些其他的尺寸限制类容器</p><ul><li><code>AspectRatio</code> 它可以指定子组件的长宽比、</li><li><code>LimitedBox</code> 用于指定最大宽高、</li><li><code>FractionallySizedBox</code> 可以根据父容器宽高的百分比来设置子组件宽高等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习GCD</title>
      <link href="/2022/05/23/be08fa8a65d5.html"/>
      <url>/2022/05/23/be08fa8a65d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="队列-FIFO"><a href="#队列-FIFO" class="headerlink" title="队列 FIFO"></a>队列 FIFO</h2><ul><li>串行队列</li><li>并发队列</li><li>全局并发队列</li><li>主队列</li></ul><p>队列只是用来存储任务，没有能力去调度任务</p><span id="more"></span><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li>同步任务 dispatch_sync<ul><li>立即执行、会阻塞当前线程、不具备开辟子线程的能力</li><li>没有线程相关的操作、没有保存任务、立即执行了任务</li></ul></li><li>异步任务 dispatch_async<ul><li>开辟子线程、不会立即执行、不会阻塞当前线程</li><li>保存block、函数式编程、有线程相关的操作</li></ul></li></ul><p>死锁： 在当前线程同步的向串行队列里面添加任务，当前线程锁执行的任务是从当前队列里取出来的</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Objc4-838</title>
      <link href="/2022/05/08/e233db870454.html"/>
      <url>/2022/05/08/e233db870454.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译Objc源码"><a href="#编译Objc源码" class="headerlink" title="编译Objc源码"></a>编译Objc源码</h1><p>要诀:<br>能删则删, 不确定先注释,<br>需加须加, 能设置就设置.</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本次编译<code>objc4-838</code>源码, 即对应<code>macOS 12.2</code>, 高版本未尝试, 理论上大版本一致可行<br>以下相关源码均可在<a href="https://opensource.apple.com/releases/">Apple Open Source</a>中 <code>macOS Monterey 12 -&gt; macOS 12.2</code> 分支看到</p><span id="more"></span><p><a href="https://github.com/apple-oss-distributions/objc4/archive/objc4-838.1.tar.gz">objc4-838 下载地址</a> </p><p><a href="https://github.com/apple-oss-distributions/dyld/archive/dyld-941.5.tar.gz">dyld-941.5 下载地址</a></p><p><a href="https://github.com/apple-oss-distributions/Libc/archive/Libc-1506.40.4.tar.gz">Libc-1506.40.4 下载地址</a></p><p><a href="https://github.com/apple-oss-distributions/libclosure/archive/libclosure-79.tar.gz">libclosure-79 下载地址</a></p><p><a href="https://github.com/apple-oss-distributions/libplatform/archive/libplatform-273.40.1.tar.gz">libplatform-273.40.1 下载地址</a></p><p><a href="https://github.com/apple-oss-distributions/libpthread/archive/libpthread-485.60.2.tar.gz">libpthread-485.60.2 下载地址</a></p><p><a href="https://github.com/apple-oss-distributions/xnu/archive/xnu-8019.80.24.tar.gz">xnu-8019.80.24 下载地址</a></p><p>旧版源码下载<br><a href="https://github.com/apple-oss-distributions/Libc/archive/Libc-825.26.tar.gz">Libc-825.26 下载地址</a> 在 <code>OS X Mountain Lion 10.8 -&gt; Mac OS X 10.8.4</code> 分支下</p><p><a href="https://github.com/apple-oss-distributions/libplatform/archive/libplatform-220.100.1.tar.gz">libplatform-220.100.1 下载地址</a>在 <code>macOS Catalina 10.15 -&gt; macOS 10.15.6</code> 分支下</p><h1 id="Project-相关"><a href="#Project-相关" class="headerlink" title="Project 相关"></a>Project 相关</h1><h2 id="修改-Base-SDK"><a href="#修改-Base-SDK" class="headerlink" title="修改 Base SDK"></a>修改 Base SDK</h2><p>在 <code>Project -&gt; Build Setting -&gt; Base SDK</code> 选择为<code>macOS</code></p><img src="/2022/05/08/e233db870454/16520180096055.jpg" class=""><h2 id="选择编译-Targets-为-objc"><a href="#选择编译-Targets-为-objc" class="headerlink" title="选择编译 Targets 为 objc"></a>选择编译 Targets 为 objc</h2><img src="/2022/05/08/e233db870454/16520180485207.jpg" class=""><h1 id="Targets-配置相关"><a href="#Targets-配置相关" class="headerlink" title="Targets 配置相关"></a>Targets 配置相关</h1><h2 id="修改-Script"><a href="#修改-Script" class="headerlink" title="修改 Script"></a>修改 Script</h2><p>在 <code>Targets -&gt; objc -&gt; Build Phases -&gt; Run Script (markgc)</code> 将 <code>macosx.internal</code> 改成 <code>macosx</code></p><img src="/2022/05/08/e233db870454/16520182953780.jpg" class=""><h2 id="编译时-报错"><a href="#编译时-报错" class="headerlink" title="编译时 报错"></a>编译时 报错</h2><p>文件缺失居多, <code>xx file not found</code></p><p>在项目根目录新增一目录, 用来放缺失文件, (名字可以自定义, 比如<code>/common</code>)<br>然后在项目 <code>Targets -&gt; Build Settings -&gt; Header Search Paths</code> 新增 <code>/common</code> 路径：<code>$(SRCROOT)/common</code></p><img src="/2022/05/08/e233db870454/16520025810206.jpg" class=""><ol><li><p><code>&#39;sys/reason.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>/bsd/sys/reason.h</code>目录下载文件<code>reason.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/sys/reason.h</code>目录</p><img src="/2022/05/08/e233db870454/16520057299390.jpg" class=""></li><li><p><code>&#39;os/feature_private.h&#39; file not found</code><br>直接注释即可, 共三处, 其<code>NSObject.mm</code>有两处</p><img src="/2022/05/08/e233db870454/16520190168277.jpg" class=""></li><li><p><code>&#39;mach-o/dyld_priv.h&#39; file not found</code><br>在<code>dyld</code>源码的<code>/include/mach-o/dyld_priv.h</code>目录下载文件<code>dyld_priv.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/mach-o/dyld_priv.h</code>目录</p><img src="/2022/05/08/e233db870454/16520057504672.jpg" class=""><p>然后要此文件添加宏定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define DYLD_MACOSX_VERSION_10_11 0x000A0B00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_12 0x000A0C00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_13 0x000A0D00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_14 0x000A0E00</span><br></pre></td></tr></table></figure></li><li><p><code>Expected &#39;,&#39;</code> 在 <code>/mach-o/dyld_priv.h</code> 文件中<br>移除<code>__API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0))</code> 中 <code>bridgeos(3.0)</code> 的条件即可</p><img src="/2022/05/08/e233db870454/16520197415089.jpg" class=""></li><li><p><code>&#39;os/lock_private.h&#39; file not found</code><br>在<code>libplatform</code>源码的<code>/private/os/lock_private.h</code>目录下载文件<code>lock_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/lock_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520057891584.jpg" class=""></li><li><p><code>Expected &#39;,&#39;</code> 在 <code>/os/lock_private.h</code> 文件中<br>移除<code>__API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0), bridgeos(4.0))</code> 中 <code>bridgeos(4.0)</code> 的条件即可</p><img src="/2022/05/08/e233db870454/16520202025735.jpg" class=""></li><li><p><code>&#39;os/base_private.h&#39; file not found</code><br>在<code>libplatform-220.100.1</code>源码的<code>/private/os/base_private.h</code>目录下载文件<code>base_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/base_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520159895858.jpg" class=""></li><li><p><code>&#39;pthread/tsd_private.h&#39; file not found</code><br>在<code>libpthread</code>源码的<code>/private/pthread/tsd_private.h</code>目录下载文件<code>tsd_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/pthread/tsd_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520160082926.jpg" class=""></li><li><p><code>&#39;System/machine/cpu_capabilities.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>/osfmk/machine/cpu_capabilities.h</code>目录下载文件<code>cpu_capabilities.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/System/machine/cpu_capabilities.h</code>目录</p><img src="/2022/05/08/e233db870454/16520160595511.jpg" class=""></li><li><p><code>&#39;os/tsd.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>libsyscall/os/tsd.h</code>目录下载文件<code>tsd.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/tsd.h</code>目录</p><img src="/2022/05/08/e233db870454/16520160761343.jpg" class=""></li><li><p><code>&#39;pthread/spinlock_private.h&#39; file not found</code><br>在<code>libpthread</code>源码的<code>/private/pthread/spinlock_private.h</code>目录下载文件<code>spinlock_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/pthread/spinlock_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520161190991.jpg" class=""></li><li><p><code>&#39;System/pthread_machdep.h&#39; file not found</code><br>在<code>Libc-825.26</code>源码的<code>/pthreads/pthread_machdep.h</code>目录下载文件<code>pthread_machdep.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/System/pthread_machdep.h</code>目录</p><img src="/2022/05/08/e233db870454/16520161567520.jpg" class=""></li><li><p><code>&#39;CrashReporterClient.h&#39; file not found</code></p></li></ol><ul><li><p>在<code>Libc-825.26</code>源码的<code>/include/CrashReporterClient.h</code>目录下载文件<code>CrashReporterClient.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/CrashReporterClient.h</code>目录</p> <img src="/2022/05/08/e233db870454/16520161828314.jpg" class=""></li><li><p>还未结束, 因为还缺少宏定义, 在 <code>Targets -&gt; objc -&gt; Build Settings -&gt; Preprocessor Macros</code> 中，添加<code>LIBC_NO_LIBCRASHREPORTERCLIENT</code></p>  <img src="/2022/05/08/e233db870454/16520040737366.jpg" class=""></li></ul><ol start="14"><li>在 <code>pthread_machdep.h</code> 文件中一个typedef和三个函数, 这些全部注释即可</li></ol><ul><li><p><code>Typedef redefinition with different types (&#39;int&#39; vs &#39;volatile OSSpinLock&#39; (aka &#39;volatile int&#39;))</code></p><img src="/2022/05/08/e233db870454/16520210232107.jpg" class=""></li><li><p><code>Static declaration of &#39;_pthread_has_direct_tsd&#39; follows non-static declaration</code></p><img src="/2022/05/08/e233db870454/16520210499881.jpg" class=""></li><li><p><code>Static declaration of &#39;_pthread_getspecific_direct&#39; follows non-static declaration</code></p><img src="/2022/05/08/e233db870454/16520210663906.jpg" class=""></li><li><p><code>Static declaration of &#39;_pthread_setspecific_direct&#39; follows non-static declaration</code></p><img src="/2022/05/08/e233db870454/16520210870245.jpg" class=""></li></ul><ol start="15"><li><p><code>Unknown type name &#39;uint32_t&#39; &#39;uint64_t, Use of undeclared identifier &#39;INT64_C&#39;</code> 在 <code>/llvm-MathExtras.h</code> 文件中<br>导入头文件 <code>#include &lt;cstdint&gt;</code> 即可解决</p><img src="/2022/05/08/e233db870454/16520218944361.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;dyld_fall_2020_os_versions&#39;</code></p><img src="/2022/05/08/e233db870454/16520219604415.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;objc4&#39; &#39;preoptimizedCaches&#39;</code></p><img src="/2022/05/08/e233db870454/16520220277190.jpg" class=""></li><li><p><code>&#39;objc-shared-cache.h&#39; file not found</code><br>在<code>dyld</code>源码的<code>/include/objc-shared-cache.h</code>目录下载文件<code>objc-shared-cache.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/objc-shared-cache.h</code>目录</p><img src="/2022/05/08/e233db870454/16520162251666.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;dyld_platform_version_macOS_10_13&#39;</code></p><img src="/2022/05/08/e233db870454/16520223502584.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;dyld_platform_version_macOS_10_11&#39;</code></p><img src="/2022/05/08/e233db870454/16520222826801.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;dyld_fall_2018_os_versions&#39;</code> 注释部分判断条件</p><img src="/2022/05/08/e233db870454/16520223139195.jpg" class=""></li><li><p><code>&#39;Block_private.h&#39; file not found</code><br>在<code>libclosure</code>源码的<code>/Block_private.h</code>目录下载文件<code>Block_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/Block_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520163360611.jpg" class=""></li><li><p><code>&#39;Cambria/Traps.h&#39; file not found</code><br>直接注释即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;Cambria/Traps.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;Cambria/Cambria.h&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&#39;_simple.h&#39; file not found</code><br>在<code>libplatform</code>源码的<code>/private/_simple.h</code>目录下载文件<code>_simple.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/_simple.h</code>目录</p><img src="/2022/05/08/e233db870454/16520162431797.jpg" class=""></li><li><p><code>&#39;os/linker_set.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>/bsd/sys/linker_set.h</code>目录下载文件<code>linker_set.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/linker_set.h</code>目录</p><img src="/2022/05/08/e233db870454/16520227164945.jpg" class=""></li><li><p><code>&#39;kern/restartable.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>/osfmk/kern/restartable.h</code>目录下载文件<code>restartable.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/kern/restartable.h</code>目录</p><img src="/2022/05/08/e233db870454/16520164250072.jpg" class=""></li><li><p><code>Use of undeclared identifier &#39;oah_is_current_process_translated&#39; 和 &#39;objc_thread_get_rip&#39;</code> 注释此<code>if</code>分支</p><img src="/2022/05/08/e233db870454/16520228608250.jpg" class=""></li><li><p><code>&#39;os/reason_private.h&#39; file not found</code><br>在<code>xnu</code>源码的<code>/libkern/os/reason_private.h</code>目录下载文件<code>reason_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/reason_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520231987128.jpg" class=""></li><li><p><code>&#39;os/variant_private.h&#39; file not found</code><br>在<code>Libc</code>源码的<code>/os/variant_private.h</code>目录下载文件<code>variant_private.h</code>文件, 拷贝至<code>/common</code>下, 对应<code>/os/variant_private.h</code>目录</p><img src="/2022/05/08/e233db870454/16520232315070.jpg" class=""><p>还要去掉文件里面的 <code>bridgeos 、 bridgeos(4.0)</code> 参数</p></li><li><p><code>Use of undeclared identifier &#39;dyld_platform_version_bridgeOS_2_0&#39; iOS_10_0 macOS_10_12 tvOS_10_0 watchOS_3_0</code> 注释此<code>if</code>判断</p><img src="/2022/05/08/e233db870454/16520234982550.jpg" class=""></li><li><p><code>&#39;_static_assert&#39; declared as an array with a negative size</code></p><img src="/2022/05/08/e233db870454/16520235358635.jpg" class=""></li></ol><h2 id="链接时-报错"><a href="#链接时-报错" class="headerlink" title="链接时 报错"></a>链接时 报错</h2><ul><li><p><code>Library not found for -lCrashReporterClient</code><br>进入 <code>Targets -&gt; objc -&gt; Build Setting -&gt; Other Linker Flags</code> 中，删除 <code>-lCrashReporterClient</code></p></li><li><p><code>Library not found for -loah</code><br>进入 <code>Targets -&gt; objc -&gt; Build Setting -&gt; Other Linker Flags</code> 中，删除 <code>-loah</code></p></li></ul><h1 id="终于-Build-Succeded"><a href="#终于-Build-Succeded" class="headerlink" title="终于 Build Succeded"></a>终于 <code>Build Succeded</code></h1><img src="/2022/05/08/e233db870454/16520238050066.jpg" class=""><h1 id="添加测试-Target"><a href="#添加测试-Target" class="headerlink" title="添加测试 Target"></a>添加测试 <code>Target</code></h1><ol><li><p>新增Target<br>点击在 <code>Target</code> 左下角的 <code>+</code>, 然后选择 <code>macOS -&gt; Command Line Tool</code>, 随便取名, 比如<code>TestOC</code></p><img src="/2022/05/08/e233db870454/16520245571391.jpg" class=""></li><li><p>链接<code>libobjc.A.dylib</code><br>选择 <code>Target -&gt; TestOC -&gt; General -&gt; Frameworks and Libraries</code> 的 <code>+</code> 然后选择 <code>libobjc.A.dylib</code> 点击 <code>Add</code></p><img src="/2022/05/08/e233db870454/16520245370237.jpg" class=""></li></ol><h1 id="编译-TestOC-Target"><a href="#编译-TestOC-Target" class="headerlink" title="编译 TestOC Target"></a>编译 TestOC Target</h1><ol><li><p>选择新 Target - TestOC</p><img src="/2022/05/08/e233db870454/16520247646137.jpg" class=""></li><li><p>愉快的在main中写代码吧</p><img src="/2022/05/08/e233db870454/16520250796382.jpg" class=""></li><li><p>此时可能会发现, 断点发虚, 无法触发</p><img src="/2022/05/08/e233db870454/16520252735294.jpg" class=""><p> 断点失败, 解决方法有二</p><ul><li>第一种: 关闭LTO(<code>Link-Time Optimization</code>),<br>  找到<code>Targets -&gt; Build Settings -&gt; Link-Time Optimization</code>, 选择值为 <code>NO</code> 即可<br>  LTO 代码链接时候的一个优化选项, Apple官方解释:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enabling this setting allows optimization across file boundaries during linking. </span><br><span class="line">**No:* </span><br><span class="line">Disabled. Do not use link-time optimization. </span><br><span class="line">**Monolithic Link-Time Optimization:*</span><br><span class="line">This mode performs monolithic link-time optimization of binaries, combining all executable code into a single unit and running aggressive compiler optimizations.</span><br><span class="line">**Incremental Link-Time Optimization:* </span><br><span class="line">This mode performs partitioned link-time optimization of binaries, inlining between compilation units and running aggressive compiler optimizations on each unit in parallel. This enables fast incremental builds and uses less memory than Monolithic LTO.</span><br></pre></td></tr></table></figure></li><li>第二种:<ol><li>找到 <code>Build Phases -&gt; Compile Sources</code> 中，确保 <code>main.m</code> 在最最最前面</li><li>找到 <code>Targets -&gt; Build Settings -&gt; Enable Hardened Runtime</code> ，确保值为 <code>NO</code></li></ol></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Xcode </tag>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 使用SFMono字体</title>
      <link href="/2019/08/29/3504b9da5c42.html"/>
      <url>/2019/08/29/3504b9da5c42.html</url>
      
        <content type="html"><![CDATA[<h3 id="从-macOS-中提取-SF-Mono-字体"><a href="#从-macOS-中提取-SF-Mono-字体" class="headerlink" title="从 macOS 中提取 SF Mono 字体"></a>从 macOS 中提取 SF Mono 字体</h3><h6 id="在-终端-中提取-SF-Mono-字体完整路径为："><a href="#在-终端-中提取-SF-Mono-字体完整路径为：" class="headerlink" title="在 终端 中提取 SF Mono 字体完整路径为："></a>在 终端 中提取 SF Mono 字体完整路径为：</h6><p><code>/Applications/Utilities/Terminal.app/Contents/Resources/Fonts/</code></p><h6 id="在-Xcode-中提取-SF-Mono-字体完整路径为："><a href="#在-Xcode-中提取-SF-Mono-字体完整路径为：" class="headerlink" title="在 Xcode 中提取 SF Mono 字体完整路径为："></a>在 Xcode 中提取 SF Mono 字体完整路径为：</h6><p><code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts</code></p><span id="more"></span><h3 id="安装到系统。"><a href="#安装到系统。" class="headerlink" title="安装到系统。"></a>安装到系统。</h3><h6 id="通过-访达-安装"><a href="#通过-访达-安装" class="headerlink" title="通过 访达 安装"></a>通过 访达 安装</h6><p>在访达中通过路径前往文件夹鼠标操作：<code>菜单栏--&gt;前往--&gt;前往文件夹</code>；快捷键操作：<code>⇧+⌘+G</code>。然后输入上面的路径前往，然后全选所有字体文件，双击安装。</p><h6 id="通过-终端-命令行安装"><a href="#通过-终端-命令行安装" class="headerlink" title="通过 终端 命令行安装"></a>通过 终端 命令行安装</h6><p>打开终端，在终端输入此命令<br><code>cp -R /Applications/Utilities/Terminal.app/Contents/Resources/Fonts/*.otf ~/Library/Fonts/</code><br>回车即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> mac </tag>
            
            <tag> 字体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go go go 2019</title>
      <link href="/2019/08/28/6aaf43c133c4.html"/>
      <url>/2019/08/28/6aaf43c133c4.html</url>
      
        <content type="html"><![CDATA[<pre><code>有点生疏了</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>判断字符是否是纯数字</title>
      <link href="/2016/11/24/e13e51eae9f1.html"/>
      <url>/2016/11/24/e13e51eae9f1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用NSScanner类， </span></span><br><span class="line">[<span class="keyword">self</span> isPureInt:text]   <span class="comment">//传入字符串并调用方法判断</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isPureInt:(<span class="built_in">NSString</span>*)string&#123;</span><br><span class="line">    <span class="built_in">NSScanner</span>* scan = [<span class="built_in">NSScanner</span> scannerWithString:string]; <span class="comment">//定义一个NSScanner，扫描string</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">return</span> [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同理 可以检测float double 等等格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[scan scanInt:&amp;val] </span></span><br><span class="line"><span class="comment">//扫描的Int类型放入val</span></span><br><span class="line"><span class="comment">//根据NSScanner的机制，如果扫描到结果需要的数据，那么它就会停在数据结尾的下一个字符处</span></span><br><span class="line"><span class="comment">//例如：string = @&quot;12ccf12&quot;;如果扫描Int类型，那么第一次扫描到第二个字符处就停止了，如果要扫描全部需要进行循环判断</span></span><br><span class="line"><span class="comment">//扫描结束后，没有到string的结尾，那么[scan isAtEnd]为NO</span></span><br><span class="line"><span class="comment">//所以</span></span><br><span class="line"><span class="comment">//[scan isAtEnd] </span></span><br><span class="line"> <span class="comment">//判断是否到结尾</span></span><br><span class="line"><span class="comment">//这样就能保证一遍扫描到结尾的数据全部是int,[scan scanInt:&amp;val] 和[scan isAtEnd]都为YES；</span></span><br><span class="line"><span class="comment">//结果isPureInt 返回YES；</span></span><br><span class="line"><span class="comment">//类似其他的判断也可以参考NSScanner</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15分钟快速学会git</title>
      <link href="/2016/09/24/c859e4c3dee5.html"/>
      <url>/2016/09/24/c859e4c3dee5.html</url>
      
        <content type="html"><![CDATA[<ol start="0"><li><p>初始化仓库<br> <strong>git init</strong> : 初始化仓库</p></li><li><p>检查状态<br> <strong>git status</strong> : 查看git状态</p></li><li><p>添加文件到缓存区<br> <strong>git add .</strong> : 把文件添加到缓存区</p></li><li><p>Committing<br> <strong>git commit -m “Add file”</strong> : 提交到缓存区</p><span id="more"></span></li><li><p>History<br> <strong>git log</strong> : 查看历史</p></li><li><p>远程存储库<br> <strong>git remote add origin &lt;git库地址&gt;</strong> : 添加到远端git库</p></li><li><p>Pushing Remotely<br> <strong>git push -u origin master</strong> : 把master分支推到远端服务器</p></li><li><p>Pulling Remotely<br><strong>git pull origin master</strong> : 从远端服务器master分支拉取</p></li><li><p>Differences 比较提交<br><strong>git diff HEAD</strong> : 比较工作目录与上次提交时之间的所有差别</p></li><li><p>Staged Differences<br><strong>git diff –staged</strong> </p></li><li><p>Resetting the Stage<br><strong>git reset &lt;file octofamily&#x2F;octodog.txt&gt;</strong></p></li><li><p>Undo 撤销<br><strong>git checkout – <file></strong> : 撤销文件自从上次提交的所有更改</p></li><li><p>Branching Out 分支<br><strong>git branch clean_up</strong> : 创建名为clean_up的分支</p></li><li><p>Switching Branch 切换分支<br><strong>git checkout clean_up</strong> : 切换到clean_up分支</p></li><li><p>Removing All The Things 删除所有文件<br><strong>git rm ‘<file name>‘</strong> : 删除文件 (有个单引号)</p></li><li><p>Committing Branch Changes  提交分支中的变换<br><strong>git commit -m “Remove all the cats”</strong> : commit</p></li><li><p>Switching Branch 切回 主分支<br><strong>git checkout master</strong> : 回到master主分支</p></li><li><p>Preparing to Merge<br><strong>git merge clean_up</strong> : 当前在master主分支下操作, 把clean_up分支合并到master主分支</p></li><li><p>Delete Branch 为了保持工作区干净 删除用完的分支</p><p><strong>git branch -d clean_up</strong> 删除本地分支  <strong>-D</strong> 是强制删除<br>删除远端 多个push<br><strong>git push origin :serverfix</strong> : <strong>冒号写法</strong> 冒号前面空格不能少, 原理是把一个空分支push到server上，相当于删除该分支<br><strong>git push origin –delete serverfix</strong> –delete写法</p></li><li><p>The Final Push 最后一步 push<br><strong>git push</strong> : 推送到远端服务器</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐藏navigationBar底部的黑线shadowImage</title>
      <link href="/2016/09/23/9adbb56f98f1.html"/>
      <url>/2016/09/23/9adbb56f98f1.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>直接设置navigationBar的shadowImage和backgroundImage,  需先让translucent属性设置为NO</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)removeBlackLine &#123;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController.navigationBar setBackgroundImage:[<span class="built_in">UIImage</span> new] forBarPosition:<span class="built_in">UIBarPositionAny</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>]; </span><br><span class="line">    [<span class="keyword">self</span>.navigationController.navigationBar setShadowImage:[<span class="built_in">UIImage</span> new]];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环遍历navigationBar的子视图，找到高度小于1的黑线, 在appear是隐藏, disappear时再显示（推荐）<span id="more"></span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *navBarHairlineImageView;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">[<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">    navBarHairlineImageView.hidden = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">[<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    navBarHairlineImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">&#125; </span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    navBarHairlineImageView= [<span class="keyword">self</span> findHairlineImageViewUnder:<span class="keyword">self</span>.navigationController.navigationBar];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIImageView</span> *)findHairlineImageViewUnder:(<span class="built_in">UIView</span> *)view &#123;  </span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:<span class="built_in">UIImageView</span>.class] &amp;&amp; view.bounds.size.height &lt;= <span class="number">1.0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">UIImageView</span> *)view;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> view.subviews) &#123;  </span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = [<span class="keyword">self</span> findHairlineImageViewUnder:subview];  </span><br><span class="line">        <span class="keyword">if</span> (imageView) &#123;  </span><br><span class="line">            <span class="keyword">return</span> imageView;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>切去超出部分, 此方法会把状态栏给切掉</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)useClipsToBoundsRemoveBlackLine &#123; <span class="keyword">self</span>.navigationController.navigationBar.clipsToBounds = <span class="literal">YES</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改rootViewController时添加动画</title>
      <link href="/2016/09/20/01edb6427252.html"/>
      <url>/2016/09/20/01edb6427252.html</url>
      
        <content type="html"><![CDATA[<p>当需要更换Window的rootViewController时，怎么给这个过程添加动画呢？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> transitionWithView:[[<span class="built_in">UIApplication</span> sharedApplication].delegate window]</span><br><span class="line">                  duration:<span class="number">0.3</span></span><br><span class="line">                   options:<span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span></span><br><span class="line">                animations:^&#123;</span><br><span class="line">                    [[[<span class="built_in">UIApplication</span> sharedApplication].delegate window] setRootViewController:viewController];</span><br><span class="line">                &#125;</span><br><span class="line">                completion:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure><p>这样写咋看咋对, 试试也是对的, <span id="more"></span> 但当横屏时会发现动画很奇怪, 后来在stackoverflow看到一个解决办法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> transitionWithView:[[<span class="built_in">UIApplication</span> sharedApplication].delegate window]</span><br><span class="line">                  duration:<span class="number">0.3</span></span><br><span class="line">                   options:<span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span></span><br><span class="line">                animations:^&#123;</span><br><span class="line">                    <span class="type">BOOL</span> oldState = [<span class="built_in">UIView</span> areAnimationsEnabled];</span><br><span class="line">                    [<span class="built_in">UIView</span> setAnimationsEnabled:<span class="literal">NO</span>];</span><br><span class="line">                    [[[<span class="built_in">UIApplication</span> sharedApplication].delegate window] setRootViewController:viewController];</span><br><span class="line">                    [<span class="built_in">UIView</span> setAnimationsEnabled:oldState];</span><br><span class="line">                &#125;</span><br><span class="line">                completion:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlertController的Click方法封装</title>
      <link href="/2016/08/31/6f517186ba1f.html"/>
      <url>/2016/08/31/6f517186ba1f.html</url>
      
        <content type="html"><![CDATA[<p>封装的AlertController, 不至于每次写alert时 好多Block回调;<br>先上 <a href="https://github.com/ijunfly/JFAlertViewController">JFAlertViewController</a>地址 <a href="https://github.com/ijunfly/JFAlertViewController">https://github.com/ijunfly/JFAlertViewController</a></p><p>每次写AlertView时每个按钮都要写一个Block来回调方法, 这样会使代码太多</p><p>创建一个继承于JFAlertViewController的属性对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) JFAlertViewController *alertAllVC;</span><br></pre></td></tr></table></figure><p>初始化时要遵循delegate和dataSource</p><span id="more"></span><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - getting</span></span><br><span class="line">- (JFAlertViewController *)alertAllVC &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_alertAllVC) &#123;</span><br><span class="line">        _alertAllVC = [JFAlertViewController alertControllerWithTitle:<span class="string">@&quot;我是标题&quot;</span> message:<span class="string">@&quot;我是消息, 消息内容的消息...&quot;</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">        _alertAllVC.delegate = <span class="keyword">self</span>;</span><br><span class="line">        _alertAllVC.dataSource = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _alertAllVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以写dataSource和delegate方法了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回选项的个数 (cancel按钮不计算在内)</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)numberOfIndexsInJFAlertView:(JFAlertViewController *)alertView;</span><br><span class="line"><span class="comment">//返回选项的title</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)JFAlertView:(JFAlertViewController *)alertView titleAtIndexNumber:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">//返回cancel按钮title, 默认是:&quot;取消&quot;</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cancelButtonTitleInJFAlertView:(JFAlertViewController *)alertView;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选项的点击事件</span></span><br><span class="line">- (<span class="type">void</span>)JFAlertView:(JFAlertViewController *)alertView clickedAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cancel按钮的点击事件</span></span><br><span class="line">- (<span class="type">void</span>)JFAlertViewCancel:(JFAlertViewController *)alertView;</span><br></pre></td></tr></table></figure><p>欢迎指正…</p><p>demo改天再传….</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放羊人与砍柴人的故事</title>
      <link href="/2016/08/30/3023662f8e20.html"/>
      <url>/2016/08/30/3023662f8e20.html</url>
      
        <content type="html"><![CDATA[<p>你是砍柴的，他是放羊的，你和他聊了一天，他的羊吃饱了，你的柴呢？ 砍柴的陪不起放羊的——请放弃你的无效社交！</p><p>你是砍柴的，他是放羊的，你和他聊了一天，如是你学会了放羊技巧，<span id="more"></span>原来羊是这么放的，他学会了砍柴技能，原来柴要这样砍——三人行必有我师，永远保持空杯的状态！</p><p>你是砍柴的，他是放羊的，你和他聊了一天，他决定把他的羊跟你的柴交换，于是你有了羊，他也有了柴——等价交换，不要看不起任何人，天生我才必有用！</p><p>你是砍柴的，他是放羊的，你和他聊了一天，他把他买羊的客户介绍给了你，你把你买柴的客户介绍给了他，于是你们各自的生意越做越大——资源整合很重要！</p><p>你是砍柴的，他是放羊的，你和他聊了一天，你们决定合作一起开个烤全羊的店，你的柴烤出来的羊很美味，他的羊纯天然的，几年后你们公司上市了——没有完美的个人，只有完美的团队！<br>……</p><p>其实面对同一件事物 心态不一样 结果就会不一样！我想说，聊可以瞎聊，沟通却是有目的的。</p><img src="/2016/08/30/3023662f8e20/160830-fangyangren.jpg" class="">]]></content>
      
      
      
        <tags>
            
            <tag> 故事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode插件管理工具-Alcatraz</title>
      <link href="/2016/08/26/7472c647ead7.html"/>
      <url>/2016/08/26/7472c647ead7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Xcode插件"><a href="#Xcode插件" class="headerlink" title="Xcode插件"></a>Xcode插件</h1><p><strong>Alcatraz</strong>是管理Xcode插件的插件,  集成在Xcode图形界面中.<br><em>Xcode8中Apple禁止了Xcode安装插件</em></p><p>手动安装Alcatraz,  在GitHub主页上找搜索<a href="https://github.com/alcatraz/Alcatraz">Alcatrazde</a> , 或者浏览器地址栏直接输入<a href="https://github.com/alcatraz/Alcatraz">https://github.com/alcatraz/Alcatraz</a></p><img src="/2016/08/26/7472c647ead7/0826-1472176469450.png" class=""><ul><li><span id="more"></span>点击[Clone or download]选择 Download ZIP (如上图)，进行下载。</li></ul><p>下载完，解压ZIP, 双击打开 .xcodeproj 可执行文件，会打开Xcode，之后运行这个项目工程</p><img src="/2016/08/26/7472c647ead7/0826-1472176649167.png" class=""><p>运行完，会出现一个会话弹出框，不要慌，这不是出现什么错误了(其实我刚开始看见这个的时候慌了一下)，淡定的点击 Load Bundles</p><img src="/2016/08/26/7472c647ead7/0826-1472176707103.png" class=""><p>然后关闭Xcode(或者command ＋ Q), 重新打开Xcode<br>点击Windows可以看到Package Manager(Shift+Command+9)</p><img src="/2016/08/26/7472c647ead7/0826-1472176837716.png" class=""><p>此时就可以打开Alcatraz管理工具了</p><img src="/2016/08/26/7472c647ead7/0826-1472177132229.png" class=""><p><a href="http://www.cocoachina.com/ios/20160122/15080.html">Xcode 插件优缺点对比（推荐 20 款插件）</a></p><p><a href="http://www.tuicool.com/articles/zUZnAfj">工作中的常用插件 for Xcode</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Xcode </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础命令</title>
      <link href="/2016/08/25/64b2c31ab32a.html"/>
      <url>/2016/08/25/64b2c31ab32a.html</url>
      
        <content type="html"><![CDATA[<p><strong>pwd</strong> 命令用于显示当前目录</p><p><strong>git init</strong>命令把这个目录变成Git可以管理的仓库</p><p>现有的仓库  <strong>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#64;&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#46;&#x31;&#46;&#50;&#x33;&#x35;">&#x67;&#x69;&#116;&#64;&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#46;&#x31;&#46;&#50;&#x33;&#x35;</a>:iOSTeam&#x2F;xxx.git</strong> 这个要替换项目地址</p><p><strong>ssh-add</strong>  ~&#x2F;.ssh&#x2F;xxx_id_rsa   添加sshKey  不至于每次输入密码</p><p>用ls -ah命令就可以看见所有文件</p><p><strong>git add</strong> 文件名字.后缀   git add  . &#x2F;&#x2F; 所有文件</p><p><strong>git status</strong> 状态<br> <span id="more"></span><br><strong>git commit  -m “xxx”</strong>  提交</p><p><strong>git log</strong>  命令查看<br>git log  –pretty&#x3D;oneline 参数  显示 commit id（版本号）</p><p><strong>git diff</strong> 查看修改内容</p><p><strong>git reset</strong> 命令 回退到上一个版本  git reset –hard HEAD^^^^  &#x2F; HEAD~4<br>还有个方法只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本：<br>git reset –hard 3628164</p><p><strong>git reflog</strong> 用来记录你的每一次命令</p><p><strong>cat readme.txt</strong>  打开文件</p><p><strong>git checkout -</strong> <file>  可以丢弃工作区的修改 ,  没有–，就变成了“切换到另一个分支”的命令，<br>git reset HEAD <file>    可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><p><strong>git rm</strong> 删掉，</p><hr><p><strong>git push origin master</strong> 推到远程master分支</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/08/20/31047e7c1977.html"/>
      <url>/2016/08/20/31047e7c1977.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><ul><li><span id="more"></span><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新的开篇</title>
      <link href="/2016/08/15/02fee1cc85dd.html"/>
      <url>/2016/08/15/02fee1cc85dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="暂时的离别是为了再次相聚时的感动"><a href="#暂时的离别是为了再次相聚时的感动" class="headerlink" title="暂时的离别是为了再次相聚时的感动"></a>暂时的离别是为了再次相聚时的感动</h1><hr><h4 id="离别"><a href="#离别" class="headerlink" title="离别"></a>离别</h4><p>离别的时候<br>每一句话都是那么重<br>缓缓地扣击着我们的心灵<br>窗被敲开了<br>我们诉说着回忆中的快乐<br>回想著一张张可爱的笑脸<br>院子里，操场上<br>充满了甜甜的空气  </p><ul><li><span id="more"></span>离别的时候<br>每一句话都是那么轻<br>轻轻地说着离别时的感言<br>轻轻的拉着彼此的手<br>轻轻地在耳际说声对不起<br>或永远祝福你</li></ul><p>离别的时候<br>每一句话都显得那么悲伤<br>离别时的感动在顷刻间爆发<br>我们，我们，我们<br>独自沉浸在自己的感伤中<br>渐渐的平息……  </p><p>离别的时候<br>每一句话都显得那么珍贵<br>仔细的听著那熟悉的声音<br>把每种都印刻在记忆里  </p><p>望著他们远去的背影，我知道，我们离别了<br>我们带著共同的回忆和永远的祝福<br>各自奔向远方……<br>轻轻哼一首离别的歌～<br>眼里噙满了泪……  </p><h4 id="重逢"><a href="#重逢" class="headerlink" title="重逢"></a>重逢</h4><p>重逢的时候<br>那是心情的又一次触动<br>惊喜的表情<br>熟悉的面庞<br>回忆中的甜蜜<br>一瞬间在脑海中隐现<br>于是，永远成为了所谓的缘分的代表<br>重逢…惊喜…<br>重逢的时候<br>那是思念的又一次宣泄<br>深情的一个拥抱<br>紧紧的一个握手<br>彼此的心轻鬆了许多<br>才发现思念是一种病<br>重逢…思念……<br>重逢的时候<br>那是记忆的又一次翻新<br>彼此回忆著孩提时的美好<br>诉说着自己的苦恼<br>谈论着朋友的生活<br>讲述着自己无奈的过往<br>重逢…记忆…<br>重逢的时候<br>那是时间的又一次停滞<br>那一刻，时间终于停了<br>自己终于可以放假<br>感动的身体一时瘫在那里<br>重逢时的感动告诉了时光老人<br>时间不能改变的东西……<br>重逢…感动…<br>重逢的时候，那是一阵欣喜，一阵感动<br>欣喜之余还有一丝的忧伤<br>因为我们毕竟还要赶路<br>那么多线终有相交的一点<br>可是相交以后注定还要分别<br>但是，至少我明白<br>暂时的离别是为了再次相聚时的感动……  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
